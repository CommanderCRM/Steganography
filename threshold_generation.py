import cv2
import numpy as np
import sympy
import statistics

# ввод пути к изображению
image_name = input("Введите название исходного изображения (с расширением): ")
image = cv2.imread(image_name)  # считываем изображение

# присваиваем переменной значение в количество пикселей изображения
image_size = image.size
# преобразуем матрицу изображения в вектор средних значений пикселей каждого ряда
mean_rows = cv2.reduce(image, 0, cv2.REDUCE_AVG)
# находим числовое среднее значение вектора, средний ключ
mean_key = np.mean(mean_rows)
lower_bound = 0  # нижняя граница подсчета простых значений пикселей
upper_bound = image_size  # верхняя граница и полное количество пикселей
# список простых чисел в промежутке от lower до upper включительно
prime_list = list(sympy.primerange(lower_bound, upper_bound + 1))
# СКО на базе простых чисел, стандартный ключ
std_key = statistics.stdev(prime_list)
# применение побитового исключающего ИЛИ к двум полученным ключам
key_xor = int(round(mean_key)) ^ int(round(std_key))

p_ideal = 100  # идеальное значение p
q_ideal = 50  # идеальное значение q
p_cust1 = 95  # первое измененное значение p
p_cust2 = 110  # второе измененное значение p
q_cust1 = 44  # первое измененное значение q
q_cust2 = 53  # второе измененное значение q

# вычисление порогового ключа по заданной формуле с идеальными значениями
th_key_ideal = p_ideal + (key_xor % q_ideal)
# пороговый ключ для измененного p
th_key_cust1 = p_cust1 + (key_xor % q_cust1)
# другой пороговый ключ для другого p
th_key_cust2 = p_cust2 + (key_xor % q_cust2)

print('Пороговый ключ на основе идеальных значений:',
      th_key_ideal)  # вывод первого ключа
print('Пороговый ключ на основе первых измененных значений:',
      th_key_cust1)  # вывод второго ключа
print('Пороговый ключ на основе вторых измененных значений:',
      th_key_cust2)  # вывод третьего ключа
