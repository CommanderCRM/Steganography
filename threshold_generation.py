import cv2
import numpy as np
import sympy
import statistics

image_name = input("Введите название исходного изображения (с расширением): ") # ввод пути к изображению
image = cv2.imread(image_name) # считываем изображение

image_size = image.size # присваиваем переменной значение в количество пикселей изображения
mean_rows = cv2.reduce(image, 0, cv2.REDUCE_AVG) # преобразуем матрицу изображения в вектор средних значений пикселей каждого ряда
mean_key = np.mean(mean_rows) # находим числовое среднее значение вектора, средний ключ
lower_bound = 0 # нижняя граница подсчета простых значений пикселей
upper_bound = image_size # верхняя граница и полное количество пикселей
prime_list = list(sympy.primerange(lower_bound, upper_bound + 1)) # список простых чисел в промежутке от lower до upper включительно
std_key = statistics.stdev(prime_list) # СКО на базе простых чисел, стандартный ключ
key_xor = int(round(mean_key)) ^ int(round(std_key)) # применение побитового исключающего ИЛИ к двум полученным ключам

p_ideal = 100 # идеальное значение p
q_ideal = 50 # идеальное значение q
p_cust1 = 95 # первое измененное значение p
p_cust2 = 110 # второе измененное значение p
q_cust1 = 44 # первое измененное значение q
q_cust2 = 53 # второе измененное значение q

th_key_ideal = p_ideal + (key_xor % q_ideal) # вычисление порогового ключа по заданной формуле с идеальными значениями
th_key_cust1 = p_cust1 + (key_xor % q_cust1) # пороговый ключ для измененного p
th_key_cust2 = p_cust2 + (key_xor % q_cust2) # другой пороговый ключ для другого p

print ('Пороговый ключ на основе идеальных значений:', th_key_ideal) # вывод первого ключа
print ('Пороговый ключ на основе первых измененных значений:', th_key_cust1) # вывод второго ключа
print ('Пороговый ключ на основе вторых измененных значений:', th_key_cust2) # вывод третьего ключа